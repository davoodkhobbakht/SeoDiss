import json
import requests
from g4f.client import Client
import os.path
from g4f.cookies import set_cookies_dir, read_cookie_files
from g4f.Provider import RetryProvider,AI365VIP,AiChats,Allyfy,Liaobots,Nexra
import g4f.debug
g4f.debug.logging = True


# WooCommerce API credentials
wc_api_url = 'https://v2ray24.store/wp-json/wc/v3/products'
consumer_key = 'ck_326169970f1de0972a0c277f86e7403a37f81bdf'
consumer_secret = 'cs_4728a3abfb658dd6fa934beeb0ed10c6ff81b86a'

# OpenAI API key
openai_api_key = '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'

# WooCommerce authentication parameters
wc_auth_params = {
    'consumer_key': consumer_key,
    'consumer_secret': consumer_secret
}
cookies_dir = os.path.join(os.path.dirname(__file__), "har_and_cookies")
set_cookies_dir(cookies_dir)
read_cookie_files(cookies_dir)


# Function to extract cookies from .har file
def load_cookies_from_har(har_file):
    with open(har_file, "r", encoding="utf-8") as f:
        har_data = json.load(f)
        
    cookies = {}
    for entry in har_data['log']['entries']:
        for cookie in entry['request']['cookies']:
            cookies[cookie['name']] = cookie['value']
    return cookies

# Load cookies from the .har file


client = Client(
)


# Function to generate text using GPT-4Free (g4f)
def generate_text_with_g4f(prompt, max_tokens=1500):

   
    response = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[{"role": "user", "content": prompt}],
    )
    
    return response.choices[0].message.content

# Function to retrieve all products from WooCommerce
def get_all_products():
    page = 1
    products = []
    while True:
        response = requests.get(f"{wc_api_url}", params={**wc_auth_params, 'page': page, 'per_page': 100})
        if response.status_code == 200:
            current_products = response.json()
            if not current_products:
                break
            products.extend(current_products)
            page += 1
        else:
            print(f"Failed to retrieve products: {response.text}")
            break
    return products

# Function to generate or update article for a WooCommerce product
def generate_article_for_product(product, update=False):
    product_id = product['id']
    product_name = product['name']
    existing_description = product.get('description', '').strip()

    if existing_description and update:
        # Append new content, asking explicitly for a continuation of the existing description
        prompt = (
    f"Expand and update the existing product description for '{product_name}' in Persian by adding more detailed "
    f"information about its features, benefits, and technical specifications while maintaining focus on the product's unique selling points. Focus on key features and present them "
    f"using a structured list in HTML (<ul><li>) format . The text should flow naturally from the existing description "
    f"underneath using <li> tags. Do not include any unnecessary or unrelated text. and fully optimized "
    f"for SEO and Marketing."
)



    else:
        # Generate a completely new description along with an SEO-optimized title
        prompt = (
    f"Write a 300-word SEO-optimized product description in Persian for '{product_name}', focusing on its general "
    f"uses, applications, and target audience. The description should introduce the product in a natural and "
    f"readable way for potential customers. Use proper HTML structure with headings (H2 and H3) and include "
    f"a short paragraph at the end with a call to action to buy the product. Make sure the HTML code is clean and "
    f"optimized for SEO.Do not include any unnecessary or unrelated text."
)



    # Get additional text or a new description from GPT-4Free
    article_content = generate_text_with_g4f(prompt, max_tokens=600).replace("```html" , "")
    article_content = article_content.replace("```" ,"")
    print('\n\n\n')
    print(article_content)
    print('\n\n\n')
    # Combine the old description and the new content, if necessary
    new_description = existing_description + " " + article_content if update and existing_description else article_content
    
    # Update the product description via the WooCommerce API
    update_data = {"description": new_description}
    update_response = requests.put(f"{wc_api_url}/{product_id}", json=update_data, params=wc_auth_params)
    
    if update_response.status_code == 200:
        print(f"Product '{product_name}' updated successfully.")
    else:
        print(f"Failed to update product '{product_name}': {update_response.text}")


# Function to generate a user question for a product
def generate_question_for_product(product_name):
    prompt = (
        f"Imagine you are a potential customer interested in '{product_name}'. "
        f"Ask a question about its features or uses or any specific details you want to know before buying. "
        f"The question should be natural, informative, and encourage the admin to give helpful advice.Write it in persian.Do not include any unnecessary or unrelated text."
    )

    response = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[{"role": "user", "content": prompt}],
    )
    
    question = response.choices[0].message.content
    return question

# Function to generate an admin reply to a user question
def generate_reply_for_question(question, product_name):
    prompt = (
        f"You're an admin for a product called '{product_name}'. Respond to the following user question in a helpful and "
        f"marketing-focused manner. Address the user's concerns, provide additional benefits and features of the product, "
        f"and encourage the user to make a purchase.Write it in persian.Do not include any unnecessary or unrelated text. The question is: '{question}'"
    )

    response = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[{"role": "user", "content": prompt}],
    )
    
    reply = response.choices[0].message.content
    return reply

# Function to post both the user question and admin reply as comments
def post_comment_and_reply(product_id, question, reply):
    # Posting the user question
    question_data = {
        "post": product_id,
        "author_name": "User",
        "author_email": "user@example.com",
        "content": question,
        "status": "publish"  # Automatically approve the comment
    }

    question_response = requests.post(wc_api_url, json=question_data, params=wc_auth_params)

    if question_response.status_code == 201:
        question_id = question_response.json().get('id')

        # Posting the admin reply
        reply_data = {
            "post": product_id,
            "author_name": "Admin",
            "author_email": "admin@example.com",
            "content": reply,
            "status": "publish",  # Automatically approve the reply
            "parent": question_id  # Link the reply to the original question
        }

        reply_response = requests.post(wc_api_url, json=reply_data, params=wc_auth_params)

        if reply_response.status_code == 201:
            print(f"Comment and reply posted successfully for product ID {product_id}")
        else:
            print(f"Failed to post admin reply: {reply_response.text}")
    else:
        print(f"Failed to post user question: {question_response.text}")

# Example usage
def generate_and_post_comments_for_product(product_id, product_name):
    question = generate_question_for_product(product_name)
    print(question)
    reply = generate_reply_for_question(question, product_name)
    print(reply)
    post_comment_and_reply(product_id, question, reply)


# Main function to handle product updates and review generation
def main():
    # Step 1: Retrieve all products
    products = get_all_products()
    '''
    for product in products :
        product_name = product['name']
        product_id = product['id']
        print(product_id,product_name)
        generate_and_post_comments_for_product(product_id, product_name)
    '''
    # Step 2: Process each product
    for product in products:
        product_name = product['name']
        existing_description = product.get('description', '').strip()

        if existing_description:
            # Step 3: Append additional text if description exists
            print(f"Appending to description for product '{product_name}'...")
            generate_article_for_product(product, update=True)
        else:
            # Step 3: Add a new description if none exists
            print(f"Adding new description for product '{product_name}'...")
            generate_article_for_product(product, update=False)

if __name__ == "__main__":
    main()
